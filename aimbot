local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local camera = workspace.CurrentCamera
local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")

local screenGui = Instance.new("ScreenGui", playerGui)
screenGui.ResetOnSpawn = false

local frame = Instance.new("Frame", screenGui)
frame.Size = UDim2.new(0, 200, 0, 120)
frame.Position = UDim2.new(0, 10, 0, 80)
frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
frame.Active = true
frame.Draggable = true
Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 10)

local toggleButton = Instance.new("TextButton", frame)
toggleButton.Size = UDim2.new(0, 180, 0, 40)
toggleButton.Position = UDim2.new(0, 10, 0, 10)
toggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
toggleButton.TextColor3 = Color3.new(1, 1, 1)
toggleButton.Font = Enum.Font.SourceSansBold
toggleButton.TextSize = 13
toggleButton.Text = "Aimbot: OFF (T)"
toggleButton.AutoButtonColor = false
Instance.new("UICorner", toggleButton).CornerRadius = UDim.new(0, 8)

local teamButton = Instance.new("TextButton", frame)
teamButton.Size = UDim2.new(0, 180, 0, 40)
teamButton.Position = UDim2.new(0, 10, 0, 70)
teamButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
teamButton.TextColor3 = Color3.new(1, 1, 1)
teamButton.Font = Enum.Font.SourceSansBold
teamButton.TextSize = 13
teamButton.Text = "TeamCheck: OFF (H)"
teamButton.AutoButtonColor = false
Instance.new("UICorner", teamButton).CornerRadius = UDim.new(0, 8)

local aimbotEnabled = false
local teamCheck = false
local currentTarget
local originalSizes = {}

local function getTargetPart(character)
	local origin = camera.CFrame.Position
	for _, name in {"Neck", "Head"} do
		local part = character:FindFirstChild(name)
		if part and part:IsA("BasePart") then
			local dir = (part.Position - origin)
			local rayParams = RaycastParams.new()
			rayParams.FilterType = Enum.RaycastFilterType.Blacklist
			rayParams.FilterDescendantsInstances = {localPlayer.Character, camera}
			rayParams.IgnoreWater = true
			local ray = workspace:Raycast(origin, dir, rayParams)
			if not ray or ray.Instance:IsDescendantOf(character) then
				local screenPos, onScreen = camera:WorldToViewportPoint(part.Position)
				if onScreen then
					return part, (Vector2.new(screenPos.X, screenPos.Y) - camera.ViewportSize / 2).Magnitude
				end
			end
		end
	end
end

local function getTarget()
	local closest, closestDist = nil, math.huge
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= localPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("Humanoid").Health > 0 then
			if not teamCheck or player.Team ~= localPlayer.Team then
				local part, dist = getTargetPart(player.Character)
				if part and dist < closestDist and dist < 150 then
					closest = player
					closestDist = dist
				end
			end
		end
	end
	return closest
end

local function expandHitbox(player)
	if player.Character then
		for _, partName in {"Head", "UpperTorso"} do
			local part = player.Character:FindFirstChild(partName)
			if part and part:IsA("BasePart") then
				originalSizes[player] = originalSizes[player] or {}
				if not originalSizes[player][partName] then
					originalSizes[player][partName] = part.Size
				end
				part.Size = part.Size + Vector3.new(2.5, 2.5, 2.5)
				part.Transparency = 0.3
				part.Material = Enum.Material.Neon
				part.Color = Color3.fromRGB(255, 0, 0)
			end
		end
	end
end

local function resetHitbox(player)
	if originalSizes[player] and player.Character then
		for partName, size in pairs(originalSizes[player]) do
			local part = player.Character:FindFirstChild(partName)
			if part then
				part.Size = size
				part.Transparency = 0
				part.Material = Enum.Material.Plastic
			end
		end
	end
end

local function updateHitboxes(state)
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= localPlayer then
			if state then
				expandHitbox(player)
			else
				resetHitbox(player)
			end
		end
	end
end

Players.PlayerAdded:Connect(function(p)
	p.CharacterAdded:Connect(function()
		if aimbotEnabled then wait(1) expandHitbox(p) end
	end)
end)

local function setAimbot(state)
	aimbotEnabled = state
	toggleButton.Text = state and "Aimbot: ON (T)" or "Aimbot: OFF (T)"
	local goalColor = state and Color3.fromRGB(60, 130, 60) or Color3.fromRGB(30, 30, 30)
	TweenService:Create(toggleButton, TweenInfo.new(0.15), {BackgroundColor3 = goalColor}):Play()
	if not state then currentTarget = nil end
	updateHitboxes(state)
end

local function setTeamCheck(state)
	teamCheck = state
	teamButton.Text = state and "TeamCheck: ON (H)" or "TeamCheck: OFF (H)"
	local goalColor = state and Color3.fromRGB(60, 130, 60) or Color3.fromRGB(30, 30, 30)
	TweenService:Create(teamButton, TweenInfo.new(0.15), {BackgroundColor3 = goalColor}):Play()
end

toggleButton.MouseButton1Click:Connect(function() setAimbot(not aimbotEnabled) end)
teamButton.MouseButton1Click:Connect(function() setTeamCheck(not teamCheck) end)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode == Enum.KeyCode.T then
		setAimbot(not aimbotEnabled)
	elseif input.KeyCode == Enum.KeyCode.H then
		setTeamCheck(not teamCheck)
	end
end)

RunService.RenderStepped:Connect(function()
	if aimbotEnabled then
		if currentTarget and currentTarget.Character and currentTarget.Character:FindFirstChild("Humanoid") then
			local part, _ = getTargetPart(currentTarget.Character)
			if part then
				camera.CFrame = CFrame.new(camera.CFrame.Position, part.Position)
			end
		else
			currentTarget = getTarget()
		end
	end
end)

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
	local method = getnamecallmethod()
	local args = {...}
	if aimbotEnabled and currentTarget and currentTarget.Character then
		local part, _ = getTargetPart(currentTarget.Character)
		if part then
			if method == "FindPartOnRayWithIgnoreList" and typeof(args[1]) == "Ray" then
				args[1] = Ray.new(camera.CFrame.Position, (part.Position - camera.CFrame.Position).Unit * 1000)
				return oldNamecall(self, unpack(args))
			elseif method == "Raycast" and typeof(args[2]) == "Vector3" then
				args[2] = (part.Position - args[1]).Unit * 1000
				return oldNamecall(self, unpack(args))
			end
		end
	end
	return oldNamecall(self, ...)
end)
